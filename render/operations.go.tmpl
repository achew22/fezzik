// Code generated by github.com/inigolabs/fezzik, DO NOT EDIT.

package {{ .PackageName }}

import (
	"context"

	"github.com/inigolabs/fezzik/client"
{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
{{- end }}
)

{{ $root := . }}

{{- range $operation := .Operations }}

{{ if ne $operation.OperationType "subscription" }}

{{range $operation.ResponseSubTypes}}
     {{.}}
{{end}}


// {{$operation.Name}}Response response type for {{$operation.Name}}
type {{ $operation.Name }}Response struct 
{{ $operation.ResponseType }}

// {{$operation.Name}} from {{ $operation.Source }}
{{- if len $operation.Inputs }}
func (c *gqlclient) {{ $operation.Name }}(ctx context.Context, 
	{{- range $val := $operation.Inputs }}
		{{ camel $val.Name }} {{ $val.Type}}, 
	{{- end }}	
	) (*{{ $operation.Name }}Response, error) {
{{- else }}
func (c *gqlclient) {{ $operation.Name }}(ctx context.Context) (*{{ $operation.Name }}Response, error) {
{{ end }}

	var {{ camel $operation.Name }}Operation string = `
	{{ $operation.Operation }}`

	gqlreq := &client.GQLRequest{
		OperationName: "{{ $operation.Name}}",
		Query: {{ camel $operation.Name }}Operation,
		Variables: map[string]interface{}{
			{{- range $val := $operation.Inputs }}	
			"{{ $val.Name }}" : {{ camel $val.Name }},
			{{- end }}
		},
	}

	resp := &client.GQLResponse{
	    Data: &{{ $operation.Name }}Response{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}


    var data *{{ $operation.Name }}Response
	if resp.Data != nil {
		data = resp.Data.(*{{ $operation.Name }}Response)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

{{end}}
{{- end }}


{{- range $operation := .Operations }}

{{ if eq $operation.OperationType "subscription" }}

{{range $operation.ResponseSubTypes}}
     {{.}}
{{end}}


// {{$operation.Name}}Response response type for {{$operation.Name}}
type {{ $operation.Name }}Response struct
{{ $operation.ResponseType }}

// {{$operation.Name}} from {{ $operation.Source }}
{{- if len $operation.Inputs }}
func (c *gqlSubscriptionClient) {{ $operation.Name }}(
	{{- range $val := $operation.Inputs }}
		{{ camel $val.Name }} {{ $val.Type}},
	{{- end }}
	fn func(out *{{ $operation.Name }}Response, err error) error,
) (string, error) {
{{- else }}
func (c *gqlSubscriptionClient) {{ $operation.Name }}(fn func(out *{{ $operation.Name }}Response, err error) error) (string, error) {
{{ end }}

	var {{ camel $operation.Name }}Operation string = `
	{{ $operation.Operation }}`

	var variables = map[string]interface{}{
        {{- range $val := $operation.Inputs }}
        "{{ $val.Name }}" : {{ camel $val.Name }},
        {{- end }}
    }

	return c.gql.Exec({{ camel $operation.Name }}Operation, variables, func(in []byte, err error) error {
        if err != nil {
            return fn(nil, err)
        }

        var out *{{ $operation.Name }}Response
        if err = json.Unmarshal(in, &out); err != nil {
            return err
        }

        return fn(out, nil)
    })
}

{{end}}
{{- end }}