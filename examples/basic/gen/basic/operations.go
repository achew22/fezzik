// Code generated by github.com/inigolabs/fezzik, DO NOT EDIT.

package basic

import (
	"context"
	"encoding/json"

	"github.com/inigolabs/fezzik/client"
	"github.com/inigolabs/fezzik/examples/basic/types"
)

type OneAllTypesOne struct {
	OneInt             *int
	OneIntMust         int
	OneIntList         *[]*int
	OneIntMustList     *[]int
	OneIntMustListMust []int
}

// OneAllTypesResponse response type for OneAllTypes
type OneAllTypesResponse struct {
	One *OneAllTypesOne
}

// OneAllTypes from examples/basic/operations/operations.graphql:2
func (c *gqlclient) OneAllTypes(ctx context.Context) (*OneAllTypesResponse, error) {

	var oneAllTypesOperation string = `
	query OneAllTypes {
	one {
		oneInt
		oneIntMust
		oneIntList
		oneIntMustList
		oneIntMustListMust
	}
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "OneAllTypes",
		Query:         oneAllTypesOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &OneAllTypesResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *OneAllTypesResponse
	if resp.Data != nil {
		data = resp.Data.(*OneAllTypesResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type OneWithSubSelectionsOne struct {
	Two *OneWithSubSelectionsOneTwo
}

type OneWithSubSelectionsOneTwo struct {
	TwoInt *int
	TwoStr *string
	Three  *OneWithSubSelectionsOneTwoThree
}

type OneWithSubSelectionsOneTwoThree struct {
	ThreeInt *int
}

// OneWithSubSelectionsResponse response type for OneWithSubSelections
type OneWithSubSelectionsResponse struct {
	One *OneWithSubSelectionsOne
}

// OneWithSubSelections from examples/basic/operations/operations.graphql:13
func (c *gqlclient) OneWithSubSelections(ctx context.Context) (*OneWithSubSelectionsResponse, error) {

	var oneWithSubSelectionsOperation string = `
	query OneWithSubSelections {
	one {
		two {
			twoInt
			twoStr
			three {
				threeInt
			}
		}
	}
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "OneWithSubSelections",
		Query:         oneWithSubSelectionsOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &OneWithSubSelectionsResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *OneWithSubSelectionsResponse
	if resp.Data != nil {
		data = resp.Data.(*OneWithSubSelectionsResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type UnionSearchResultInLineSearch struct {
	Typename *string `json:"__typename"`
	*UnionSearchResultInLineSearchBook
	*AuthorFr
}

func (f *UnionSearchResultInLineSearch) UnmarshalJSON(data []byte) error {
	type alias UnionSearchResultInLineSearch

	var val *alias
	if err := json.Unmarshal(data, &val); err != nil {
		return err
	}

	*f = UnionSearchResultInLineSearch(*val)

	f.AuthorFr = nil
	f.UnionSearchResultInLineSearchBook = nil

	if val.Typename != nil && *val.Typename == "Author" {
		if err := json.Unmarshal(data, &f.AuthorFr); err != nil {
			return err
		}
	}

	if val.Typename != nil && *val.Typename == "Book" {
		if err := json.Unmarshal(data, &f.UnionSearchResultInLineSearchBook); err != nil {
			return err
		}
	}

	return nil
}

func (f UnionSearchResultInLineSearch) MarshalJSON() ([]byte, error) {
	var data = struct {
		Name     string
		Title    string
		Typename *string `json:"__typename"`
		Updated  string
	}{}

	data.Typename = f.Typename

	if f.Typename != nil && *f.Typename == "Book" {
		data.Title = f.UnionSearchResultInLineSearchBook.Title
	}

	if f.Typename != nil && *f.Typename == "Book" {
		data.Updated = f.UnionSearchResultInLineSearchBook.Updated
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Name = f.AuthorFr.Name
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Updated = f.AuthorFr.Updated
	}

	return json.Marshal(data)
}

type UnionSearchResultInLineSearchBook struct {
	Title   string
	Updated string
}

type AuthorFr struct {
	Name    string
	Updated string
}

// UnionSearchResultInLineResponse response type for UnionSearchResultInLine
type UnionSearchResultInLineResponse struct {
	Search []UnionSearchResultInLineSearch
}

// UnionSearchResultInLine from examples/basic/operations/operations.graphql:27
func (c *gqlclient) UnionSearchResultInLine(ctx context.Context) (*UnionSearchResultInLineResponse, error) {

	var unionSearchResultInLineOperation string = `
	query UnionSearchResultInLine {
	search {
		__typename
		... on Book {
			title
			updated
		}
		... AuthorFr
	}
}
fragment AuthorFr on Author {
	name
	updated
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "UnionSearchResultInLine",
		Query:         unionSearchResultInLineOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &UnionSearchResultInLineResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *UnionSearchResultInLineResponse
	if resp.Data != nil {
		data = resp.Data.(*UnionSearchResultInLineResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type UnionSearchResultSearch struct {
	Typename *string `json:"__typename"`
	*BookFr
	*AuthorFr
	*AuthorAnotherFr
}

func (f *UnionSearchResultSearch) UnmarshalJSON(data []byte) error {
	type alias UnionSearchResultSearch

	var val *alias
	if err := json.Unmarshal(data, &val); err != nil {
		return err
	}

	*f = UnionSearchResultSearch(*val)

	f.AuthorAnotherFr = nil
	f.AuthorFr = nil
	f.BookFr = nil

	if val.Typename != nil && *val.Typename == "Author" {
		if err := json.Unmarshal(data, &f.AuthorAnotherFr); err != nil {
			return err
		}
	}

	if val.Typename != nil && *val.Typename == "Author" {
		if err := json.Unmarshal(data, &f.AuthorFr); err != nil {
			return err
		}
	}

	if val.Typename != nil && *val.Typename == "Book" {
		if err := json.Unmarshal(data, &f.BookFr); err != nil {
			return err
		}
	}

	return nil
}

func (f UnionSearchResultSearch) MarshalJSON() ([]byte, error) {
	var data = struct {
		Name     string
		Title    string
		Typename *string `json:"__typename"`
		Updated  string
	}{}

	data.Typename = f.Typename

	if f.Typename != nil && *f.Typename == "Book" {
		data.Title = f.BookFr.Title
	}

	if f.Typename != nil && *f.Typename == "Book" {
		data.Updated = f.BookFr.Updated
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Name = f.AuthorFr.Name
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Updated = f.AuthorFr.Updated
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Name = f.AuthorAnotherFr.Name
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Updated = f.AuthorAnotherFr.Updated
	}

	return json.Marshal(data)
}

type BookFr struct {
	Title   string
	Updated string
}

type AuthorAnotherFr struct {
	Name    string
	Updated string
}

// UnionSearchResultResponse response type for UnionSearchResult
type UnionSearchResultResponse struct {
	Search []UnionSearchResultSearch
}

// UnionSearchResult from examples/basic/operations/operations.graphql:39
func (c *gqlclient) UnionSearchResult(ctx context.Context) (*UnionSearchResultResponse, error) {

	var unionSearchResultOperation string = `
	query UnionSearchResult {
	search {
		__typename
		... BookFr
		... AuthorFr
		... AuthorAnotherFr
	}
}
fragment BookFr on Book {
	title
	updated
}
fragment AuthorFr on Author {
	name
	updated
}
fragment AuthorAnotherFr on Author {
	name
	updated
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "UnionSearchResult",
		Query:         unionSearchResultOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &UnionSearchResultResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *UnionSearchResultResponse
	if resp.Data != nil {
		data = resp.Data.(*UnionSearchResultResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type UnionSearchResultNoTypenameSearch struct {
	Typename *string `json:"__typename"`
	*BookFr
	*AuthorFr
}

func (f *UnionSearchResultNoTypenameSearch) UnmarshalJSON(data []byte) error {
	type alias UnionSearchResultNoTypenameSearch

	var val *alias
	if err := json.Unmarshal(data, &val); err != nil {
		return err
	}

	*f = UnionSearchResultNoTypenameSearch(*val)

	f.AuthorFr = nil
	f.BookFr = nil

	if val.Typename != nil && *val.Typename == "Author" {
		if err := json.Unmarshal(data, &f.AuthorFr); err != nil {
			return err
		}
	}

	if val.Typename != nil && *val.Typename == "Book" {
		if err := json.Unmarshal(data, &f.BookFr); err != nil {
			return err
		}
	}

	return nil
}

func (f UnionSearchResultNoTypenameSearch) MarshalJSON() ([]byte, error) {
	var data = struct {
		Name     string
		Title    string
		Typename *string `json:"__typename"`
		Updated  string
	}{}

	data.Typename = f.Typename

	if f.Typename != nil && *f.Typename == "Book" {
		data.Title = f.BookFr.Title
	}

	if f.Typename != nil && *f.Typename == "Book" {
		data.Updated = f.BookFr.Updated
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Name = f.AuthorFr.Name
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Updated = f.AuthorFr.Updated
	}

	return json.Marshal(data)
}

// UnionSearchResultNoTypenameResponse response type for UnionSearchResultNoTypename
type UnionSearchResultNoTypenameResponse struct {
	Search []UnionSearchResultNoTypenameSearch
}

// UnionSearchResultNoTypename from examples/basic/operations/operations.graphql:49
func (c *gqlclient) UnionSearchResultNoTypename(ctx context.Context) (*UnionSearchResultNoTypenameResponse, error) {

	var unionSearchResultNoTypenameOperation string = `
	query UnionSearchResultNoTypename {
	search {
		__typename
		... BookFr
		... AuthorFr
	}
}
fragment BookFr on Book {
	title
	updated
}
fragment AuthorFr on Author {
	name
	updated
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "UnionSearchResultNoTypename",
		Query:         unionSearchResultNoTypenameOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &UnionSearchResultNoTypenameResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *UnionSearchResultNoTypenameResponse
	if resp.Data != nil {
		data = resp.Data.(*UnionSearchResultNoTypenameResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type InterfaceGetCreatedGetCreated struct {
	Created  string
	Typename *string `json:"__typename"`
	*BookFr
	*AuthorFr
}

func (f *InterfaceGetCreatedGetCreated) UnmarshalJSON(data []byte) error {
	type alias InterfaceGetCreatedGetCreated

	var val *alias
	if err := json.Unmarshal(data, &val); err != nil {
		return err
	}

	*f = InterfaceGetCreatedGetCreated(*val)

	f.AuthorFr = nil
	f.BookFr = nil

	if val.Typename != nil && *val.Typename == "Author" {
		if err := json.Unmarshal(data, &f.AuthorFr); err != nil {
			return err
		}
	}

	if val.Typename != nil && *val.Typename == "Book" {
		if err := json.Unmarshal(data, &f.BookFr); err != nil {
			return err
		}
	}

	return nil
}

func (f InterfaceGetCreatedGetCreated) MarshalJSON() ([]byte, error) {
	var data = struct {
		Created  string
		Name     string
		Title    string
		Typename *string `json:"__typename"`
		Updated  string
	}{}

	data.Created = f.Created

	data.Typename = f.Typename

	if f.Typename != nil && *f.Typename == "Book" {
		data.Title = f.BookFr.Title
	}

	if f.Typename != nil && *f.Typename == "Book" {
		data.Updated = f.BookFr.Updated
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Name = f.AuthorFr.Name
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Updated = f.AuthorFr.Updated
	}

	return json.Marshal(data)
}

// InterfaceGetCreatedResponse response type for InterfaceGetCreated
type InterfaceGetCreatedResponse struct {
	GetCreated []InterfaceGetCreatedGetCreated
}

// InterfaceGetCreated from examples/basic/operations/operations.graphql:57
func (c *gqlclient) InterfaceGetCreated(ctx context.Context) (*InterfaceGetCreatedResponse, error) {

	var interfaceGetCreatedOperation string = `
	query InterfaceGetCreated {
	getCreated {
		created
		__typename
		... BookFr
		... AuthorFr
	}
}
fragment BookFr on Book {
	title
	updated
}
fragment AuthorFr on Author {
	name
	updated
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "InterfaceGetCreated",
		Query:         interfaceGetCreatedOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &InterfaceGetCreatedResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *InterfaceGetCreatedResponse
	if resp.Data != nil {
		data = resp.Data.(*InterfaceGetCreatedResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type InterfaceGetCreatedNoTypenameGetCreated struct {
	Created  string
	Typename *string `json:"__typename"`
	*BookFr
	*AuthorFr
}

func (f *InterfaceGetCreatedNoTypenameGetCreated) UnmarshalJSON(data []byte) error {
	type alias InterfaceGetCreatedNoTypenameGetCreated

	var val *alias
	if err := json.Unmarshal(data, &val); err != nil {
		return err
	}

	*f = InterfaceGetCreatedNoTypenameGetCreated(*val)

	f.AuthorFr = nil
	f.BookFr = nil

	if val.Typename != nil && *val.Typename == "Author" {
		if err := json.Unmarshal(data, &f.AuthorFr); err != nil {
			return err
		}
	}

	if val.Typename != nil && *val.Typename == "Book" {
		if err := json.Unmarshal(data, &f.BookFr); err != nil {
			return err
		}
	}

	return nil
}

func (f InterfaceGetCreatedNoTypenameGetCreated) MarshalJSON() ([]byte, error) {
	var data = struct {
		Created  string
		Name     string
		Title    string
		Typename *string `json:"__typename"`
		Updated  string
	}{}

	data.Created = f.Created

	data.Typename = f.Typename

	if f.Typename != nil && *f.Typename == "Book" {
		data.Title = f.BookFr.Title
	}

	if f.Typename != nil && *f.Typename == "Book" {
		data.Updated = f.BookFr.Updated
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Name = f.AuthorFr.Name
	}

	if f.Typename != nil && *f.Typename == "Author" {
		data.Updated = f.AuthorFr.Updated
	}

	return json.Marshal(data)
}

// InterfaceGetCreatedNoTypenameResponse response type for InterfaceGetCreatedNoTypename
type InterfaceGetCreatedNoTypenameResponse struct {
	GetCreated []InterfaceGetCreatedNoTypenameGetCreated
}

// InterfaceGetCreatedNoTypename from examples/basic/operations/operations.graphql:67
func (c *gqlclient) InterfaceGetCreatedNoTypename(ctx context.Context) (*InterfaceGetCreatedNoTypenameResponse, error) {

	var interfaceGetCreatedNoTypenameOperation string = `
	query InterfaceGetCreatedNoTypename {
	getCreated {
		created
		__typename
		... BookFr
		... AuthorFr
	}
}
fragment BookFr on Book {
	title
	updated
}
fragment AuthorFr on Author {
	name
	updated
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "InterfaceGetCreatedNoTypename",
		Query:         interfaceGetCreatedNoTypenameOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &InterfaceGetCreatedNoTypenameResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *InterfaceGetCreatedNoTypenameResponse
	if resp.Data != nil {
		data = resp.Data.(*InterfaceGetCreatedNoTypenameResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type OneWithAliasOne struct {
	OneInt *int
}

type OneWithAliasTwo struct {
	OneInt *int
}

// OneWithAliasResponse response type for OneWithAlias
type OneWithAliasResponse struct {
	One *OneWithAliasOne
	Two *OneWithAliasTwo
}

// OneWithAlias from examples/basic/operations/operations.graphql:91
func (c *gqlclient) OneWithAlias(ctx context.Context) (*OneWithAliasResponse, error) {

	var oneWithAliasOperation string = `
	query OneWithAlias {
	one {
		oneInt
	}
	two: one {
		oneInt
	}
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "OneWithAlias",
		Query:         oneWithAliasOperation,
		Variables:     map[string]interface{}{},
	}

	resp := &client.GQLResponse{
		Data: &OneWithAliasResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *OneWithAliasResponse
	if resp.Data != nil {
		data = resp.Data.(*OneWithAliasResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

type QueryWithInputsOne struct {
	OneInt *int
}

type QueryWithInputsTwo struct {
	TwoInt *int
}

// QueryWithInputsResponse response type for QueryWithInputs
type QueryWithInputsResponse struct {
	One *QueryWithInputsOne
	Two *QueryWithInputsTwo
}

// QueryWithInputs from examples/basic/operations/operations.graphql:102
func (c *gqlclient) QueryWithInputs(ctx context.Context,
	inputOne *string,
	inputTwo *string,
) (*QueryWithInputsResponse, error) {

	var queryWithInputsOperation string = `
	query QueryWithInputs ($input_one: String, $input_two: String) {
	one(input: $input_one) {
		oneInt
	}
	two(input: $input_two) {
		twoInt
	}
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "QueryWithInputs",
		Query:         queryWithInputsOperation,
		Variables: map[string]interface{}{
			"input_one": inputOne,
			"input_two": inputTwo,
		},
	}

	resp := &client.GQLResponse{
		Data: &QueryWithInputsResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *QueryWithInputsResponse
	if resp.Data != nil {
		data = resp.Data.(*QueryWithInputsResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

// OneAddResponse response type for OneAdd
type OneAddResponse struct {
	OneAdd *string
}

// OneAdd from examples/basic/operations/operations.graphql:113
func (c *gqlclient) OneAdd(ctx context.Context,
	input *OneInput,
) (*OneAddResponse, error) {

	var oneAddOperation string = `
	mutation OneAdd ($input: OneInput) {
	oneAdd(input: $input)
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "OneAdd",
		Query:         oneAddOperation,
		Variables: map[string]interface{}{
			"input": input,
		},
	}

	resp := &client.GQLResponse{
		Data: &OneAddResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *OneAddResponse
	if resp.Data != nil {
		data = resp.Data.(*OneAddResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

// TwoAddResponse response type for TwoAdd
type TwoAddResponse struct {
	TwoAdd *string
}

// TwoAdd from examples/basic/operations/operations.graphql:118
func (c *gqlclient) TwoAdd(ctx context.Context,
	input *types.TwoInput,
) (*TwoAddResponse, error) {

	var twoAddOperation string = `
	mutation TwoAdd ($input: TwoInput) {
	twoAdd(input: $input)
}
`

	gqlreq := &client.GQLRequest{
		OperationName: "TwoAdd",
		Query:         twoAddOperation,
		Variables: map[string]interface{}{
			"input": input,
		},
	}

	resp := &client.GQLResponse{
		Data: &TwoAddResponse{},
	}

	err := c.gql.Query(ctx, gqlreq, resp)
	if err != nil {
		return nil, err
	}

	var data *TwoAddResponse
	if resp.Data != nil {
		data = resp.Data.(*TwoAddResponse)
	}

	if resp.Errors == nil {
		return data, nil
	}

	return data, resp.Errors
}

// UpdatedResponse response type for Updated
type UpdatedResponse struct {
	Updated *types.ServerResult
}

// Updated from examples/basic/operations/operations.graphql:122
func (c *gqlSubscriptionClient) Updated(fn func(out *UpdatedResponse, err error) error) (string, error) {

	var updatedOperation string = `
	subscription Updated {
	updated {
		id
	}
}
`

	var variables = map[string]interface{}{}

	return c.gql.Exec(updatedOperation, variables, func(in []byte, err error) error {
		if err != nil {
			return fn(nil, err)
		}

		var out *UpdatedResponse
		if err = json.Unmarshal(in, &out); err != nil {
			return err
		}

		return fn(out, nil)
	})
}

// ChangedResponse response type for Changed
type ChangedResponse struct {
	Changed *types.ServerResult
}

// Changed from examples/basic/operations/operations.graphql:128
func (c *gqlSubscriptionClient) Changed(
	input *string,
	fn func(out *ChangedResponse, err error) error,
) (string, error) {

	var changedOperation string = `
	subscription Changed ($input: String) {
	changed(input: $input) {
		id
	}
}
`

	var variables = map[string]interface{}{
		"input": input,
	}

	return c.gql.Exec(changedOperation, variables, func(in []byte, err error) error {
		if err != nil {
			return fn(nil, err)
		}

		var out *ChangedResponse
		if err = json.Unmarshal(in, &out); err != nil {
			return err
		}

		return fn(out, nil)
	})
}
